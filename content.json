{"meta":{"title":"lzzZ","subtitle":"","description":"","author":"lzzZ","url":"https://leaningzzz.github.io/blog","root":"/blog/"},"pages":[{"title":"Categories","date":"2023-02-11T16:31:29.070Z","updated":"2023-02-11T16:31:29.070Z","comments":false,"path":"categories/index.html","permalink":"https://leaningzzz.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"1234.替换子串得到平衡字符串","slug":"leetcode/1234-替换子串得到平衡字符串","date":"2023-02-13T13:08:27.000Z","updated":"2023-02-13T13:10:10.292Z","comments":true,"path":"2023/02/13/leetcode/1234-替换子串得到平衡字符串/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/13/leetcode/1234-%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目链接https://leetcode.cn/problems/replace-the-substring-for-balanced-string 思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @lc app=leetcode.cn id=1234 lang=javascript * * [1234] 替换子串得到平衡字符串 */// @lc code=start/** * @param &#123;string&#125; s * @return &#123;number&#125; */var balancedString = function (s) &#123; const avg = s.length / 4; let count = &#123; Q: 0, W: 0, E: 0, R: 0 &#125; const checkNum = () =&gt; &#123; // 是否超出平均 for (let key in count) &#123; if (count[key] &gt; avg) &#123; return true &#125; &#125; return false &#125; for (const char of s) &#123; count[char] += 1 &#125; let min = s.length, left = 0; right = 0 while (right &lt;= s.length &amp;&amp; left &lt;= right) &#123; console.log(&#x27;while&#x27;) if (checkNum()) &#123; count[s[right]] -= 1 right++ &#125; else &#123; count[s[left]] += 1 min = Math.min(min, right - left) left++ &#125; &#125; return min&#125;;const s = &quot;QWERQEEE&quot;console.log(balancedString(s))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leaningzzz.github.io/blog/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"1138.字母板上的路径","slug":"leetcode/1138-字母板上的路径","date":"2023-02-12T11:56:01.000Z","updated":"2023-02-12T12:03:53.952Z","comments":true,"path":"2023/02/12/leetcode/1138-字母板上的路径/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1138-%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目链接https://leetcode.cn/problems/alphabet-board-path 思路 从第一个字符开始，找到当前字符在board中的xIndex和yIndex 根据currentIndex和当前字符的xIndex和yIndex，计算该往左右或上下移动 统计结果 循环第二个字符 需要注意z字符的移动，不能超出边界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @lc app=leetcode.cn id=1138 lang=javascript * * [1138] 字母板上的路径 */// @lc code=start/** * @param &#123;string&#125; target * @return &#123;string&#125; */var alphabetBoardPath = function (target) &#123; const board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;] let result = &#x27;&#x27;, curX = 0, curY = 0 for (let i = 0; i &lt; target.length; i++) &#123; const cur = target[i] let xIndex, yIndex board.forEach((item, index) =&gt; &#123; if (item.includes(cur)) &#123; yIndex = index xIndex = item.indexOf(cur) &#125; &#125;) const x = xIndex - curX, y = yIndex - curY const xArr = new Array(Math.abs(x)).fill(x &gt; 0 ? &#x27;R&#x27; : &#x27;L&#x27;), yArr = new Array(Math.abs(y)).fill(y &gt; 0 ? &#x27;D&#x27; : &#x27;U&#x27;) // 需要从其他格子前往z格时，先移动x轴，再移动y轴 // 先移动y轴的话，有可能撞到边界 if (cur === &#x27;z&#x27;) &#123; result += xArr.join(&#x27;&#x27;) + yArr.join(&#x27;&#x27;) + &#x27;!&#x27; &#125; else &#123; result += yArr.join(&#x27;&#x27;) + xArr.join(&#x27;&#x27;) + &#x27;!&#x27; &#125; [curX, curY] = [xIndex, yIndex] &#125; return result&#125;;const target = &quot;zb&quot;// &quot;DDDDD!UUUUURRR!DDDDLLLD!&quot;console.log(alphabetBoardPath(target))// &quot;zb&quot;// 输出：// &quot;DDDDD!RUUUUU!&quot;// 预期结果：// &quot;DDDDD!UUUUUR!&quot;// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"html","slug":"interview/html","date":"2023-02-11T17:54:53.902Z","updated":"2023-02-12T12:49:12.186Z","comments":true,"path":"2023/02/12/interview/html/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/interview/html/","excerpt":"","text":"htmlHTML DOCTYPE的含义？什么是HTML的标准模式与混杂模式？doctype: 文档类型声明，说明这个页面使用什么来编写的。 1&lt;!doctype html&gt; HTML5有哪些语义化标签及其特性？HTML元素有哪些分类与特性？123456&lt;body /&gt;&lt;article /&gt;&lt;nav /&gt;&lt;aside /&gt;&lt;header /&gt;&lt;footer /&gt; 根据结构化的内容，选择合适的标签。 有利于seo。 代码更好的可读性。 标签上加alt 、title，方便其他设备进行解析。 如何检测浏览器是否支持HTML5特性？ 检查特定属性和方法 123!!navigator.geolocation // 地理位置!!window.localStorage!!window.Worker 创建一个元素，看看特定元素有没有对应的属性和方法。 12!!document.createElement(&#x27;canvas&#x27;).getContext!!document.createElement(&#x27;video&#x27;).canPlayType 第三方库 http://modernizr.cn/ HTML中meta的作用？HTML的标签有哪些可以优化SEO？ 保证页面时ssr的 meta中的name相关属性。 123&lt;meta name=&quot;author&quot; content=&quot;aaa@gmail.com&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;xxx xxx system&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;xxx xxx&quot; /&gt; 语义化标签，以一些结构化标签为主。 title meta article header aside footer DOM和BOM有什么区别？javaScript在浏览器环境下一般️由三部分构成。 ECMAScript 核心，描述了js的语法和基本对象。 DOM 文档对象模型，document。提供了一些api，可以操作文档。例如：操作页面元素。 BOM 浏览器对象模型，borwser。提供了一些api，可以操作浏览器。例如：操作路由。 如何实现移动端适配？ 使用媒体查询，根据不同屏幕尺寸设置不同样式。 使用百分比、vw&#x2F;vh，避免使用px。 rem方案。 1px问题先放大 200%，然后 scale(0.5)。 rem方案rem 指 html 的 font-size 大小。 如何禁用页面中的右键、打印、另存为、复制等功能？1234567891011121314151617181920212223// 1. 禁用右键document.oncontextmenu = function () &#123; return false;&#125;document.onmousedown = function(event)&#123; if(event.button === 2)&#123; return false &#125;&#125;// 2. 禁止复制&lt;body oncopy=&quot;nocopy()&quot; /&gt;function nocopy(evenr)&#123; event.returnValue = false&#125;// 3. 禁用f12document.onkeydown = function(event)&#123; if(window.event &amp;&amp; window.event.keyCode === 123)&#123; window.event.returnValue = false &#125;&#125; href&#x3D;”javascript:void(0)”和href&#x3D;”#”区别是什么？href&#x3D;”#”: 锚点默认是#top，会让网页往上走javascript: void(0): 死链接。 对target&#x3D;”_blank”的理解？有什么安全性问题？如何防范？ 当你使用target&#x3D;”_blank”打开一个新的标签页时，新页面的window对象上有一个属性 opener ,它指向的是前一个页面的window对象，因此，后一个新打开的页面就可以控制前一个页面了. 类似与window.open，子页面会拿到当前的句柄。window.opener 123if(window.opener)&#123; window.opener.location.href = &#x27;bad.html&#x27;&#125; 1&lt;a href=&quot;x.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferer&quot;&gt;跳转&lt;/a&gt; 简述页面的存储区别？什么是本地存储？怎么做离线缓存？ cookie 每个cookie不能超过4kb 每个域 20个 比较耗费性能 [ key, value, domain, expireTime, httpOnly, sec, ss ] web storage localStorage： 永久存储 sessionStorage： 会话存储 5MB indexdDB 相当于浏览器端的数据库 application cache pwa service worker 离线缓存 什么是canvas？什么时候需要使用canvas？画布常见动画方案： css svg canvas 什么是PWA？渐进式网页应用核心技术： app mainfest service worker web push 什么是Shadow DOM？web component：真正做到组件化。 原生规范，无需框架，无需编译。 真正意义上的css scope。 123456customElements.define(&#x27;shadow-text&#x27;, class extends HTMLElement &#123; connectedCallback()&#123; const shadow = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;) shadow.innerHtml = &#x27;this is a shadow dom&#x27; &#125;&#125;) iframe有哪些应用？如处理iframe通信？什么是web worker？为什么要使用web worker? web worker赋予了js应用在主线程之外重开一个单独线程的能力，该线程与主线程相分离，互不影响。可通过postMessage、onMessage两个api来进行通信。 避免耗时操作阻塞主线程（将耗时操作移到worker线程中进行，操作结束后通知主线程） 什么是SSO打通？怎么做前端沙盒模式？浏览器的渲染和布局逻辑是什么？ DOM 树构建 CSS 树构建 DOM树 + CSS树 &#x3D; 渲染树构建 页面布局 页面绘制 页面的重绘回流是什么？怎样计算首屏和白屏的时间？常统计的页面性能数据指标包括？页面上有哪些领域可以做进一步的性能优化？浏览器之间的线程调度是怎么做的？","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"html","slug":"html","permalink":"https://leaningzzz.github.io/blog/tags/html/"}]},{"title":"异步","slug":"interview/promise","date":"2023-02-11T17:53:41.010Z","updated":"2023-02-12T12:49:16.944Z","comments":true,"path":"2023/02/12/interview/promise/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/interview/promise/","excerpt":"","text":"异步promisepromise实现 执行resolve -&gt; fulfilled 执行reject -&gt; rejected promise状态改变后不可改变 如果有报错，相当于执行reject 初始状态为pending 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class myPromise &#123; constructor(executor) &#123; // 初始化，定义初始状态 this.initValue() // 初始化this指向 this.initBind() // 执行传入的函数 // catch 执行reject try &#123; executor(this.resolve, this.reject) &#125; catch (e) &#123; this.reject(e) &#125; &#125; initValue() &#123; this.promiseResult = null this.promiseState = &#x27;pending&#x27; this.onFulfilledCbs = [] // 成功回调 this.onRejectedCbs = [] // 失败回调 &#125; initBind() &#123; // this绑定到实例上，方便链式调用？ this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; resolve(value) &#123; if (this.promiseState !== &#x27;pending&#x27;) &#123; return &#125; this.promiseResult = value this.promiseState = &#x27;fulfilled&#x27; // 执行保存的成功过回调 while (this.onFulfilledCbs.length) &#123; this.onFulfilledCbs.shift()(this.promiseResult) &#125; &#125; reject(reason) &#123; if (this.promiseState !== &#x27;pending&#x27;) &#123; return &#125; this.promiseResult = reason this.promiseState = &#x27;rejected&#x27; while (this.onRejectedCbs.length) &#123; this.onRejectedCbs.shift()(this.promiseResult) &#125; &#125; then(onFulfilled, onRejected) &#123; // 参数类型判断 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; // 保证链式调用，返回一个新的promise对象 const thenPromise = new myPromise((resolve, reject) =&gt; &#123; const resolvePromise = (cb) =&gt; &#123; try &#123; console.log(&#x27;=======&gt;cb&#x27;, cb) const x = cb(this.promiseResult) if (x &amp;&amp; x === thenPromise) &#123; throw new Error(&#x27;不能返回自身&#x27;) &#125; if (x instanceof myPromise) &#123; x.then(resolve, reject) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; reject(e) throw new Error(e) &#125; &#125; // 状态不为pending -&gt; 执行对应状态的回调 // 状态为pending -&gt; 保存回调，异步结束后执行 if (this.promiseState === &#x27;fulfilled&#x27;) &#123; resolvePromise(onFulfilled) &#125; else if (this.promiseState === &#x27;rejected&#x27;) &#123; resolvePromise(onRejected) // onRejected(this.promiseResult) &#125; else if (this.promiseState === &#x27;pending&#x27;) &#123; this.onFulfilledCbs.push(resolvePromise.bind(this, onFulfilled)) this.onRejectedCbs.push(resolvePromise.bind(this, onRejected)) &#125; &#125;) return thenPromise &#125;&#125;console.log(&#x27;========&gt;1&#x27;)const test = new myPromise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(&#x27;aaa&#x27;) &#125;, 300)&#125;)console.log(&#x27;========&gt;2&#x27;)test.then(res =&gt; console.log(&#x27;====&gt;res&#x27;, res))console.log(&#x27;========&gt;3&#x27;, test.then(res =&gt; console.log(&#x27;====&gt;res&#x27;, res))) promise.all 接收⼀个Promise数组，数组中如有⾮Promise项，则此项当做成功 如果所有Promise都成功，则返回成功结果数组 如果有⼀个Promise失败，则返回这个失败结果 1234567891011121314151617181920static all(promises) &#123; const result = [] let count = 0 return new MyPromise((resolve, reject) =&gt; &#123; const addData = (index, value) =&gt; &#123; result[index] = value count++ if (count === promises.length) resolve(result) &#125; promises.forEach((promise, index) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(index, res) &#125;, err =&gt; reject(err)) &#125; else &#123; addData(index, promise) &#125; &#125;) &#125;)&#125; promise.race 接收promise数组，如果有非promise的值，返回成功 返回最快得到结果的promise 12345678910111213race(promises) &#123; return new myPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; reject(err)) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; promise.allSettled 接受promise数组，如果有非promise值，返回成功 保存所有promise结果(成功+失败)，返回数组 123456789101112131415161718192021222324252627allSettled(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const res = [] let count = 0 const addData = (status, value, i) =&gt; &#123; res[i] = &#123; status, value &#125; count++ if (count === promises.length) &#123; resolve(res) &#125; &#125; promises.forEach((promise, i) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(&#x27;fulfilled&#x27;, res, i) &#125;, err =&gt; &#123; addData(&#x27;rejected&#x27;, err, i) &#125;) &#125; else &#123; addData(&#x27;fulfilled&#x27;, promise, i) &#125; &#125;) &#125;)&#125; promise.any 接收promise数组，若有非promise直接返回成功 有一个promise成功，返回成功 全部失败报错 1234567891011121314151617181920static any(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach((promise) =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; count++ if (count === promises.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27; )) &#125; &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; async await12345678910111213function request(num)&#123; return new Promise((res,rej)=&gt;&#123; setTimeout(()=&gt;&#123; res(num * 2) &#125;,1000) &#125;)&#125;request(1).then(res1=&gt;&#123; console.log(res1)&#125;)request(2).then(res1=&gt;&#123; console.log(res1)&#125;) 如果 await 后面跟的不是promise，是没法实现类似异步转同步的效果的，例如await 一个 setTimeout generator","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"}]},{"title":"css","slug":"interview/css","date":"2023-02-11T17:18:22.432Z","updated":"2023-02-12T12:49:10.108Z","comments":true,"path":"2023/02/12/interview/css/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/interview/css/","excerpt":"","text":"CSS块级元素和行内元素转换的方式有哪些？ display 1display: block / inline-block float 1float: left/right =&gt; display: block =&gt; 去除行内元素之间的空白问题 position 1position: absolute /fixed 选择器 &amp; 优先级选择器的优先级是什么样的？1234567891011121314内联样式 权重最高 1000id选择器 #id 100类选择器 .class 10属性选择器 a[ref=&#x27;link&#x27;] 10标签选择器 div 1伪类选择器 li:last-child 10伪元素选择器 li:before 1兄弟选择器 div+p 0子选择器 ul&gt;li 0后代选择器 li a 0通配符 * 0 特殊场景优先级如何判断？ !important 优先级最高 如果优先级相同，后者高于前者 继承得到的样式，优先级是最低的 可继承的样式有哪些？ 字体 font-family font-weight font-size font-style 文本 text-indent 缩进 text-align line-height word-spacing letter-spacing color 元素 visibility 列表布局 list-style 光标 cursor 隐藏和显示相关有哪些隐藏元素的方法？有什么区别？ display:none; 不占位 visibility: hidden; 占位 opacity: 0; 占位 z-index: 负值; 不占位（被覆盖了） transform: scale(0, 0); 占位（位置变小了） display 和 visibility 有什么区别？ 都可以让元素进行隐藏&#x2F;展示。 浏览器渲染时，display不占据空间，渲染书中会不存在；visibility 占据一根树枝，只是不进行展示。 visibility 是可继承，而display不会被继承。 性能影响上，display会导致文档重排，但是修改visibility只会导致文本重绘。 盒模型及其特性简单说说标准盒模型、IE盒模型分别是什么？如何转换？盒模型特点：content + padding + border + margin 区别：标准盒模型： width 和 height 只包含 content 部分。IE盒模型： width 和 height 包含了 content + padding + border 转换方式：box-sizing: content-box &#x2F; border-box 伪元素和伪类是什么？区别是什么？伪元素： 只出现在css样式表中，不存在与文档流中。 1234567p::before&#123; content: &#x27;aa&#x27;;&#125;p::first-line&#123; background: red;&#125; 伪类：在已有的元素上加上特殊的类别，不产生新的类别。 123456div:hover&#123; color: red;&#125;li:last-child&#123; color: red;&#125; 图片格式和css-sprites图片格式有哪些？怎么应用？如何选择？ BMP：无损、无压缩。通常体积较大。 GIF：无损，采用了LZW压缩算法。仅支持8bit索引色，色彩还原度较差，但支持动图。 JPEG：有损、直接色存储，适合还原度要求较高的场景。 PNG-8：无损、使用索引色。体积更优秀，并且支持透明度调节。 PNG-24：无损，使用直接色存储。 SVG：无损，放大不会失真，适合做logo、icon webP：有损+无损、使用直接色、支持透明度、压缩。兼容性不太好。 css-sprites 精灵图、雪碧图怎么处理？把所有涉及到的图片放到一张大图中，利用background-image将一张大图加载到页面中，通过background-repeat + background-position将对应图片移动到窗口中显示。 优点： 性能缺点： 开发、维护 像素密度和图片应用像素密度有了解吗？经典设备宽高 414px 896px物理像素 1242px 2688px 1242 &#x2F; 414 &#x3D; 3 &#x3D;&gt; 逻辑像素 ： 物理像素 &#x3D; 1 ：3&#x3D;&gt; 像素密度、DPI 3&#x3D;&gt; 3倍屏 如何在图片的加载上应用动态密度？设计师提供 2x 3x 图片 12345678image&#123; background: (&#x27;1x.png&#x27;)&#125;@media only screen and (min-device-pixel-ratio: 3)&#123; image&#123; background: (&#x27;3x.png&#x27;) &#125;&#125; css工程化与预处理css类库与工程化的理解？预处理器：less csss stylus&#x3D;&gt; 利用编译库提供能力，提供层级、mixin、变量、循环、函数 后处理器：postCss&#x3D;&gt; 利用后处理编译，给写好的css增加一些属性或进行变量替换，实现跨浏览器兼容 单行、多行文本超出手写一个单行 &amp; 多行文本超出省略12345678910111213141516171819202122232425262728293031&lt;!--单行超出--&gt;style&#123; overflow:hidden; text-overflow: ellipsis; // 超出省略号 wite-space: nowrap; // 不换行&#125;&lt;!--多行超出--&gt;style&#123; overflow:hidden; text-overflow: ellipsis; // 超出省略号 display: -webkit-box; // 弹性伸缩盒子模型 -webkit-box-orient: vertical; // 从上往下垂直排列 -webkit-line-clamp: 3; // 显示行数&#125;&lt;!--兼容性方案--&gt;p&#123; position: relative; line-height: 18px; height: 40px; // 必须知道行高 overflow: hidden;&#125;p::after&#123; content: &#x27;...&#x27;; position: absolute; bottom: 0; right: 0;&#125;&lt;!--方案不足：必须固定行高 =&gt; js处理 后处理器处理--&gt; px em rem多种单位的区别","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leaningzzz.github.io/blog/tags/css/"}]},{"title":"http","slug":"interview/http","date":"2023-02-11T17:18:22.423Z","updated":"2023-02-12T12:49:14.337Z","comments":true,"path":"2023/02/12/interview/http/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/interview/http/","excerpt":"","text":"什么是http？什么是https？http：基于 tcp&#x2F;id。是一个客户端和服务端请求和响应的标准，用于从 www 服务器传输超文本到本地浏览器的超文本传输协议。 https：是以安全为目标的 HTTP 通道，通过在 HTTP 下加入 SSL 层进行加密。其作用是 建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 http 和 https 的区别和优缺点？ http 是超文本传输协议，信息是明文传输。HTTPS 协议要比 HTTP 协议更加安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。 http 协议的默认端口为80，https 的默认端口为 443。 https 协议需要 ca 证书，费用较高。 SSL 证书需要绑定 IP。 https 协议的工作原理？ 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 连接。 web 服务器收到客户端的请求之后，会将网站的证书（包含公钥）传输给客户端。 客户端和 web 服务器端开始协商 ssl 链接的安全等级（加密等级）。 客户端、浏览器通过双方协商一致的安全登记，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 客户端通过会话密钥加密与客户端之间的通信。 https 一定是安全的吗？不一定。中间人攻击。中间人与用户或服务器在同一个局域网，中间人可以截获用户的数据包，包括SSL数据包，并做一个假的服务器SSL证书与用户通信，从而截获用户输入的机密信息。当网站被假的SSL证书替换时，浏览器会警告用户此证书不受信任，需要用户确认是否信任此证书，用户习惯性点击“继续浏览”，中间人攻击轻而易举的实现了。 什么是三次握手？三次握手是客户端与服务器在建立TCP连接时的步骤。在握手的过程中传送的包里不含数据，三次握手完毕后，客户端和服务器才正式开始传送数据。 第一次握手： 建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入 SYN_SENT 状态，等待服务器确认。 第二次握手：服务器收到syn包，并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack&#x3D;k+1），此包发送完毕，客户端与服务器进入*ESTABLTSHED（TCP连接成功）*状态，完成三次握手。 TCP和UDP的区别？ TCP 是面向连接的，UDP无连接。 TCP 仅支持单播传输，UDP 提供了单播、多播、广播的功能。 TCP 可靠，三次握手保证了连接的可靠性。UDP 不可靠，UDP 是无连接的，通信不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。 UDP 开销小（不需要连接），数据传输效率更高，实时性更好。 什么是请求跨域？跨域指由于浏览器的同源同域策略，不能执行其他网站的脚本。（为了安全）同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。 怎么解决请求跨域的问题？ JSONPscript标签、image标签中的src属性不受浏览器同源同域策略影响，因此可以利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。 12345678910111213//动态创建 scriptvar script = document.createElement(&#x27;script&#x27;)// 设置回调函数function getData(data) &#123; console.log(data)&#125;//设置 script 的 src 属性，并设置请求地址script.src = &#x27;http://localhost:3000/?callback=getData&#x27;// 让 script 生效document.body.appendChild(script) 缺点：只支持get CORSCORS(Cross-origin resource sharing)跨域资源共享。服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求 proxy代理目前常用方式,通过服务器设置代理。客户端向服务端请求会产生跨域，但服务端向服务端请求不存在跨域。 cookie、localStorage、sessionStorage的区别 相同点：都是客户端用来数据持久化的 不同点： 大小不同。cookie约4KB，sessionStorage和localStorage的存储比cookie大得多，可以达到5M+。 cookie设置过期时间，在过期时间之内一直有效；localStorage不手动清理一直有效；sessionStorage只在当前回话有效，关闭浏览器后会清空。 cookie的数据会随着请求发到服务端，localStorage、sessionStorage的数据存在本地。 从输入URL到页面加载的全过程 浏览器输入url并回车。 查找缓存，看浏览器缓存中是否有该页面，如果有的话显示页面内容，没有则往下进行DNS解析。 浏览器缓存 操作系统缓存 路由器缓存 ISP缓存（？） DNS解析。向DNS服务器发送请求，获取该url域名所对应的id地址。（UDP连接）。 建立TCP连接：通过解析到的ip地址和默认80端口，建立TCP连接。 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器。 服务端相应结果，并返回对应html。 关闭TCP连接（四次挥手）。 浏览器渲染，客户端解析HTML的内容并渲染出来。 构建DOM树。 构建CSS tree。 DOM树和CSS树结合，构建出渲染树（render tree）。 布局 绘制 浏览器缓存强缓存协商缓存 体现的状态码","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"http","slug":"http","permalink":"https://leaningzzz.github.io/blog/tags/http/"}]},{"title":"2331.计算布尔二叉树的值","slug":"leetcode/2331-计算布尔二叉树的值","date":"2023-02-11T17:10:58.000Z","updated":"2023-02-11T17:12:43.027Z","comments":true,"path":"2023/02/12/leetcode/2331-计算布尔二叉树的值/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/2331-%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%80%BC/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * * [2331] 计算布尔二叉树的值 * * 思路： * 递归 * root.val为0或1时，返回对应的false或true * root.val为2或3时，递归计算值，并取 || 或 &amp;&amp; *//* * @lc app=leetcode.cn id=2331 lang=javascript * * [2331] 计算布尔二叉树的值 */// @lc code=start/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var evaluateTree = function (root) &#123; // 0: false // 1: true // 2: or // 3: and // root = [2,1,3,null,null,0,1] function loop(root) &#123; if (root.val === 0) return false if (root.val === 1) return true if (root.val === 2) return loop(root.left) || loop(root.right) if (root.val === 3) return loop(root.left) &amp;&amp; loop(root.right) &#125; return loop(root)&#125;;// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"1797.设计一个验证系统","slug":"leetcode/1797-设计一个验证系统","date":"2023-02-11T17:10:37.000Z","updated":"2023-02-11T17:12:43.020Z","comments":true,"path":"2023/02/12/leetcode/1797-设计一个验证系统/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1797-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @param &#123;number&#125; timeToLive */var AuthenticationManager = function (timeToLive) &#123; this.timeToLive = timeToLive this.tokenMap = new Map()&#125;;/** * @param &#123;string&#125; tokenId * @param &#123;number&#125; currentTime * @return &#123;void&#125; */AuthenticationManager.prototype.generate = function (tokenId, currentTime) &#123; if (!this.tokenMap.has(tokenId)) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null&#125;;/** * @param &#123;string&#125; tokenId * @param &#123;number&#125; currentTime * @return &#123;void&#125; */AuthenticationManager.prototype.renew = function (tokenId, currentTime) &#123; if (this.tokenMap.has(tokenId) &amp;&amp; this.tokenMap.get(tokenId) + this.timeToLive &gt; currentTime) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null&#125;;/** * @param &#123;number&#125; currentTime * @return &#123;number&#125; */AuthenticationManager.prototype.countUnexpiredTokens = function (currentTime) &#123; let nums = 0 this.tokenMap.forEach((value, key) =&gt; &#123; if (value + this.timeToLive &gt; currentTime) &#123; nums++ &#125; &#125;) return nums&#125;;/** * Your AuthenticationManager object will be instantiated and called as such: * var obj = new AuthenticationManager(timeToLive) * obj.generate(tokenId,currentTime) * obj.renew(tokenId,currentTime) * var param_3 = obj.countUnexpiredTokens(currentTime) */class AuthenticationManager &#123; constructor(timeToLive) &#123; this.timeToLive = timeToLive this.tokenMap = new Map() &#125; generate(tokenId, currentTime) &#123; if (!this.tokenMap.has(tokenId)) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null &#125; renew(tokenId, currentTime) &#123; if (this.tokenMap.has(tokenId) &amp;&amp; this.tokenMap.get(tokenId) + this.timeToLive &gt; currentTime) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null &#125; countUnexpiredTokens(currentTime) &#123; let nums = 0 this.tokenMap.forEach((value, key) =&gt; &#123; if (value + this.timeToLive &gt; currentTime) &#123; nums++ &#125; &#125;) return nums &#125;&#125;// const authenticationManager = new AuthenticationManager(5)// authenticationManager.renew(&quot;aaa&quot;, 1)// authenticationManager.generate(&quot;aaa&quot;, 2)// authenticationManager.countUnexpiredTokens(6)// authenticationManager.generate(&quot;bbb&quot;, 7)// authenticationManager.renew(&quot;aaa&quot;, 8)// authenticationManager.renew(&quot;bbb&quot;, 10)// authenticationManager.countUnexpiredTokens(15)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"1604.警告一小时内使用相同员工卡大于等于三次的人","slug":"leetcode/1604-警告一小时内使用相同员工卡大于等于三次的人","date":"2023-02-11T17:10:14.000Z","updated":"2023-02-11T17:12:43.013Z","comments":true,"path":"2023/02/12/leetcode/1604-警告一小时内使用相同员工卡大于等于三次的人/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1604-%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * * [1604] 警告一小时内使用相同员工卡大于等于三次的人 * * 思路： * 1. 输入数据格式化，转换成key value形式 * 2. 对每个成员的打卡数据进行分析 * 2.1 打卡数据转为分钟数 * 2.2 排序 * 2.3 从第二个数据开始(i=2)，如果 times[i] - times[i=2] &gt;=60，符合条件，否则i++ * 2.4 如果存在符合条件的打卡数据，则为true，否则为false * 3. 将所有true的成员进行排序 * 4. 输出 *//* * @lc app=leetcode.cn id=1604 lang=javascript * * [1604] 警告一小时内使用相同员工卡大于等于三次的人 */// @lc code=start/** * @param &#123;string[]&#125; keyName * @param &#123;string[]&#125; keyTime * @return &#123;string[]&#125; *//** * @param &#123;string[]&#125; keyName * @param &#123;string[]&#125; keyTime * @return &#123;string[]&#125; */var alertNames = function (keyName, keyTime) &#123; const obj = &#123;&#125; for (let i = 0; i &lt; keyName.length; i++) &#123; const name = keyName[i] if (!obj[name]) &#123; obj[name] = [] &#125; obj[name].push(keyTime[i]) &#125; const timeToMin = (time) =&gt; &#123; const [hour, min] = time.split(&#x27;:&#x27;) return Number(hour * 60) + Number(min) &#125; const check = (times) =&gt; &#123; times = times.map(item =&gt; timeToMin(item)).sort((a, b) =&gt; a - b) for (let i = 2; i &lt; times.length; i++) &#123; if (times[i] - times[i - 2] &lt;= 60) &#123; return true &#125; &#125; return false &#125; return Object.keys(obj).filter(item =&gt; check(obj[item])).sort()&#125;;console.log(alertNames([&quot;daniel&quot;, &quot;daniel&quot;, &quot;daniel&quot;, &quot;luis&quot;, &quot;luis&quot;, &quot;luis&quot;, &quot;luis&quot;], [&quot;10:00&quot;, &quot;10:40&quot;, &quot;11:00&quot;, &quot;09:00&quot;, &quot;11:00&quot;, &quot;13:00&quot;, &quot;15:00&quot;]))// // @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"1233.删除子文件夹","slug":"leetcode/1233-删除子文件夹","date":"2023-02-11T17:09:50.000Z","updated":"2023-02-11T17:12:43.005Z","comments":true,"path":"2023/02/12/leetcode/1233-删除子文件夹/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @lc app=leetcode.cn id=1233 lang=javascript * * [1233] 删除子文件夹 */// @lc code=start/** * @param &#123;string[]&#125; folder * @return &#123;string[]&#125; */// var removeSubfolders = function (folder) &#123;// folder = folder.sort()// const arr = new Set([])// for (let i = 0; i &lt; folder.length; i++) &#123;// for (let j = i + 1; j &lt; folder.length; j++) &#123;// console.log(folder[i], folder[j], i, j)// if (folder[j].indexOf(folder[i]) === 0 &amp;&amp; folder[i] !== folder[j]) &#123;// console.log(folder[i], folder[j], i, j)// if (folder[j].split(folder[i])[1][0] === &#x27;/&#x27;) &#123;// // 排除/a/b/c /a/b/ca// console.log(folder[i], folder[j], i, j)// arr.add(j)// &#125;// &#125;// &#125;// &#125;// return folder.filter((item, index) =&gt; &#123;// return ![...arr].includes(index)// &#125;)// &#125;;var removeSubfolders = function (folder) &#123; folder = folder.sort() const result = new Set() for (let i = 0; i &lt; folder.length; i++) &#123; let str = &#x27;/&#x27;, isSon = false for (let j = 1; j &lt; folder[i].length; j++) &#123; if (folder[i][j] === &#x27;/&#x27; &amp;&amp; result.has(str)) &#123; isSon = true break &#125; str += folder[i][j] &#125; if (!isSon) &#123; result.add(folder[i]) &#125; &#125; return [...result]&#125;;// @lc code=end// const folder = [&quot;/a&quot;, &quot;/a/b&quot;, &quot;/c/d&quot;, &quot;/c/d/e&quot;, &quot;/c/f&quot;]// const folder = [&quot;/ah/al/am&quot;, &quot;/ah/al&quot;]const folder = [&quot;/a&quot;, &quot;/a/b/c&quot;, &quot;/a/b/d&quot;]// const folder = [&quot;/a&quot;, &quot;/a/b&quot;, &quot;/c/d&quot;, &quot;/c/d/e&quot;, &quot;/c/f&quot;]console.log(removeSubfolders(folder))","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"20.有效括号","slug":"leetcode/20-有效括号","date":"2023-02-11T17:09:18.000Z","updated":"2023-02-11T17:12:43.001Z","comments":true,"path":"2023/02/12/leetcode/20-有效括号/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334/* * @lc app=leetcode.cn id=20 lang=javascript * * [20] 有效的括号 */// @lc code=start/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function (s) &#123; const map = &#123; &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27; &#125; const arr = [] for (let i = 0; i &lt; s.length; i++) &#123; if (map[s[i]]) &#123;//left arr.push(s[i]) &#125; else &#123; if (map[arr[arr.length - 1]] !== s[i]) &#123; return false &#125; arr.pop() &#125; &#125; return arr.length === 0&#125;;s = &quot;(]&quot;console.log(isValid(s))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"2335.装满杯子需要的最短总时长","slug":"leetcode/2335-装满杯子需要的最短总时长","date":"2023-02-11T16:32:23.000Z","updated":"2023-02-11T17:12:43.035Z","comments":true,"path":"2023/02/12/leetcode/2335-装满杯子需要的最短总时长/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/2335-%E8%A3%85%E6%BB%A1%E6%9D%AF%E5%AD%90%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E7%9F%AD%E6%80%BB%E6%97%B6%E9%95%BF/","excerpt":"","text":"12345678910111213141516171819202122232425262728/* * @lc app=leetcode.cn id=2335 lang=javascript * * [2335] 装满杯子需要的最短总时长 */// @lc code=start/** * @param &#123;number[]&#125; amount * @return &#123;number&#125; */var fillCups = function (amount) &#123; let [first, second, third] = amount.sort((a, b) =&gt; a - b) console.log(first, second, third) if (first + second &lt;= third) &#123; return third &#125; else &#123; return Math.ceil((first + second + third) / 2) &#125;&#125;;// const amount = [1, 4, 2]const amount = [7, 10, 1]console.log(fillCups(amount))// @lc code=end// 3 + 2 + 2","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[]},{"title":"react基础","slug":"react/react基础","date":"2023-02-11T16:32:03.000Z","updated":"2023-02-12T14:45:53.443Z","comments":true,"path":"2023/02/12/react/react基础/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/react/react%E5%9F%BA%E7%A1%80/","excerpt":"","text":"事件中，箭头函数和bind的区别 事件 react合成事件，统一挂载到根元素上 挂载到根元素上的弊端 React.portal 父组件更新，子组件一定更新吗？ 子组件更新，父组件会不会更新？ shouldComponentUpdate在provider&#x2F;context更新时无效，即总会render 性能优化 pureComponent：相当于在shouldComponent里进行浅对比 React.memo shouldComponentUpdate 反模式？ 组件通信— 父 -&gt; 子 props context provider consumer 性能优化组件复用HOC高阶段组件 属性代理 反向继承 高阶组件的问题 内部黑盒 &#x3D;&gt; 增加理解成本假设通过HOC生成了一个Comp组件。此时如果想了解Comp组件的逻辑，则需要同时查看HOC组件的逻辑以及传入HOC的入参组件逻辑 属性覆盖阿大使 render propshooks useState useEffect useRef useImperativeHandle useCallback useMemo useContext useReducer React18新特性Suspence + React.lazyssr流式渲染renderToPipableStream transition(https://www.qycn.com/xzx/article/14478.html) immutable","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-02-11T14:57:51.248Z","updated":"2023-02-11T16:23:24.331Z","comments":true,"path":"2023/02/11/hello-world/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new &quot;My New Post&quot; More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"},{"name":"知识点总结","slug":"知识点总结","permalink":"https://leaningzzz.github.io/blog/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leaningzzz.github.io/blog/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"html","slug":"html","permalink":"https://leaningzzz.github.io/blog/tags/html/"},{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"},{"name":"css","slug":"css","permalink":"https://leaningzzz.github.io/blog/tags/css/"},{"name":"http","slug":"http","permalink":"https://leaningzzz.github.io/blog/tags/http/"}]}
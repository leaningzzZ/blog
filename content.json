{"meta":{"title":"lzzZ","subtitle":"","description":"","author":"lzzZ","url":"https://leaningzzz.github.io/blog","root":"/blog/"},"pages":[{"title":"分类","date":"2023-02-14T08:02:59.130Z","updated":"2023-02-14T08:02:59.130Z","comments":false,"path":"categories/index.html","permalink":"https://leaningzzz.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"防抖、节流","slug":"interview/防抖、节流","date":"2023-02-23T07:23:18.000Z","updated":"2023-02-23T07:41:47.597Z","comments":true,"path":"2023/02/23/interview/防抖、节流/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/23/interview/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/","excerpt":"","text":"概念避免高频操作 防抖：触发高频事件后n秒内函数只会执行一次,如果n秒内高频事件再次被触发,则重新计算时间。 节流：间隔n秒触发一次。 实现防抖 设置一个定时器 如果n秒内被再次触发，则清除定时器，重新设置 12345678910const debounce = (fn, delay)=&gt;&#123; let timer = null return function()&#123; const context = this if(timer) clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(context, arguments); &#125;,delay) &#125;&#125; 节流 设置flag flag一段时间后为true，执行函数 12345678910111213const throttle = (fn,delay)=&gt;&#123; let flag = true return function()&#123; let context = this if(flag)&#123; setTimeout(()=&gt;&#123; fn.apply(context,arguments) flag = true &#125;, delay) flag = false &#125; &#125;&#125;","categories":[{"name":"手写题","slug":"手写题","permalink":"https://leaningzzz.github.io/blog/categories/%E6%89%8B%E5%86%99%E9%A2%98/"}],"tags":[]},{"title":"浏览器","slug":"basic/浏览器","date":"2023-02-22T06:54:01.000Z","updated":"2023-02-22T07:38:18.012Z","comments":true,"path":"2023/02/22/basic/浏览器/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/22/basic/%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"cookie、localStorage、sessionStorage的区别 相同点：都是客户端用来数据持久化的 不同点： 大小不同。cookie约4KB，sessionStorage和localStorage的存储比cookie大得多，可以达到5M+。 cookie设置过期时间，在过期时间之内一直有效；localStorage不手动清理一直有效；sessionStorage只在当前回话有效，关闭浏览器后会清空。 cookie的数据会随着请求发到服务端，localStorage、sessionStorage的数据存在本地。 从输入URL到页面加载的全过程 浏览器输入url并回车。 查找缓存，看浏览器缓存中是否有该页面，如果有的话显示页面内容，没有则往下进行DNS解析。 浏览器缓存 操作系统缓存 路由器缓存 ISP缓存（？） DNS解析。向DNS服务器发送请求，获取该url域名所对应的id地址。（UDP连接）。 建立TCP连接：通过解析到的ip地址和默认80端口，建立TCP连接。 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器。 服务端相应结果，并返回对应html。 关闭TCP连接（四次挥手）。 浏览器渲染，客户端解析HTML的内容并渲染出来。 构建DOM树。 构建CSS tree。 DOM树和CSS树结合，构建出渲染树（render tree）。 布局 绘制 浏览器缓存背景 浏览器每次发送请求时，都会先在浏览器缓存中查找该请求的结果及缓存标识。 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。 强缓存当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 ExpiresHttp 1.0控制缓存的字段，标识缓存过期时间，即再次发起请求时，若客户端的时间小于Expires的时间，则使用该缓存。 现在默认使用Http 1.1，Expires被cache-control取代。原因在于客户端时间不准确。当Expires和cache-control同时存在时，expires优先级小于cache-control Cache-controlhttp 1.1中用于判断缓存的字段，主要取值有： public：所有的内容都将被缓存（客户端 + 服务端） private：所有的内容只有客户端可以被缓存（默认值） no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存验证决定 no-store：所有内容都不会被缓存 max-age：缓存失效时间（xxx秒后缓存失效） 协商缓存缓存失效后，客户端携带缓存标识向服务端发送请求，服务端根据缓存标识决定是否使用缓存，主要有两种情况： 缓存生效，返回304 协商缓存失效，返回200 协商缓存的标识在响应头中返回给浏览器。协商缓存的控制字段主要有：Last-Modified&#x2F;If-Modified-Since和Etag&#x2F;If-None-Match，其中Etag&#x2F;If-None-Match的优先级高于Last-Modified&#x2F;If-Modified-Since Last-Modified &#x2F; If-Modified-Since last–modified存在于响应头中，是服务端响应请求时，该资源在服务端最后被修改的时间。 if-modified-since存在于请求头中，为服务端发起请求时，携带上一次请求返回的last-modified值。服务端收到请求后发现请求头含有If-Modified-Since字段，则会根据if-modified-since的值于服务端资源最后被修改时间进行对比。若资源被修改时间大于if-modified-since，则重新返回资源，状态码为200，否则返回304，代表资源未更新，可以使用缓存。 Etag &#x2F; If-None-Match Etag为服务端返还给客户端的一个资源唯一标识 if-none-match是客户端再次发起请求时，携带的上一次返回的etag值。服务端收到请求后，若发现存在if-none-match字段，则会根据该字段的值与服务器的Etag进行对比，若一致，则返回304，代表资源未更新；若不一致则重新返回资源文件，状态码为200。 重排重绘分别是什么？定义重绘：repaint，当元素样式的改变不影响布局时，浏览器重新对元素进行更新的过程叫做重绘。重排：reflow，当页面元素的尺寸、结构或某些特定属性发生改变时，浏览器重新渲染部分或全部文档的过程叫做重排，也称为回流。 重绘不一定重排，重排一定重绘 如何触发重排、重绘？重绘元素样式改变触发。例如： background等属性改变 重排 增加或删除可见的dom元素，导致文档排列变化 元素位置发生改变 元素尺寸发生改变 浏览器窗口发生改变 页面初始化 如何避免重排、重绘？ 合并视图操作，不要一条一条的修改dom样式。可以先定义好css的className，随后将className添加到元素上。 对具有复杂动画的元素使用绝对定位，使其脱离文档流。避免引起父元素及后续元素频繁回流。 避免频繁操作dom。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"浏览器","slug":"浏览器","permalink":"https://leaningzzz.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"https://leaningzzz.github.io/blog/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"50.pow-x-n","slug":"leetcode/50-pow-x-n","date":"2023-02-21T04:38:51.000Z","updated":"2023-02-22T02:43:23.593Z","comments":true,"path":"2023/02/21/leetcode/50-pow-x-n/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/21/leetcode/50-pow-x-n/","excerpt":"","text":"题目https://leetcode.cn/problems/powx-n/ 思路 直接计算 分治 代码直接计算12345678/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; return x**n&#125;; 分治法12345678910111213141516171819202122/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function (x, n) &#123; if (n === 0) &#123; return 1 &#125; if (n === 1) &#123; return x &#125; if (n &lt; 0) &#123; return 1 / myPow(x, -n) &#125; // 奇数 if (n % 2) &#123; return x * myPow(x, n - 1); &#125; // 偶数 return myPow(x * x, n / 2)&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"2347.最好的扑克手牌","slug":"leetcode/2347-最好的扑克手牌","date":"2023-02-20T03:24:27.000Z","updated":"2023-02-20T03:26:36.330Z","comments":true,"path":"2023/02/20/leetcode/2347-最好的扑克手牌/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/20/leetcode/2347-%E6%9C%80%E5%A5%BD%E7%9A%84%E6%89%91%E5%85%8B%E6%89%8B%E7%89%8C/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657```# 题目&lt;https://leetcode.cn/problems/best-poker-hand&gt;# 思路通过set判断同花和高牌通过一次循环来判断三对和两对# 代码```js/* * @lc app=leetcode.cn id=2347 lang=javascript * * [2347] 最好的扑克手牌 */// @lc code=start/** * @param &#123;number[]&#125; ranks * @param &#123;character[]&#125; suits * @return &#123;string&#125; */var bestHand = function (ranks, suits) &#123; if ([...new Set(suits)].length === 1) &#123; return &#x27;Flush&#x27; &#125; if (ranks.length === [...new Set(ranks)].length) &#123; return &#x27;High Card&#x27; &#125; const sorted = ranks.sort((a, b) =&gt; a - b) let isPair = false, isThreeOfAKind = false for (let i = 0; i &lt; sorted.length - 1; i++) &#123; if (sorted[i] === sorted[i + 1] &amp;&amp; sorted[i + 1] === sorted[i + 2]) &#123; isThreeOfAKind = true &#125; if (sorted[i] === sorted[i + 1]) &#123; isPair = true &#125; &#125; if (isThreeOfAKind) &#123; return &#x27;Three of a Kind&#x27; &#125; if (isPair) &#123; return &#x27;Pair&#x27; &#125;&#125;;// const ranks = [13, 2, 3, 1, 9], suits = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]// const ranks = [4, 4, 2, 4, 4], suits = [&quot;d&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]const ranks = [10, 10, 2, 12, 9], suits = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;]console.log(bestHand(ranks, suits))// @lc code=end","categories":[],"tags":[]},{"title":"使用JS实现带并发的异步任务调度器","slug":"interview/使用JS实现带并发的异步任务调度器","date":"2023-02-16T06:27:15.000Z","updated":"2023-02-16T06:54:17.896Z","comments":true,"path":"2023/02/16/interview/使用JS实现带并发的异步任务调度器/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/16/interview/%E4%BD%BF%E7%94%A8JS%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%B9%B6%E5%8F%91%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/","excerpt":"","text":"题目实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有N个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出： 1234567891011121314151617181920class Scheduler &#123; add(promiseCreator) &#123; ... &#125; // ...&#125;const timeout = (time) =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, time)&#125;)const scheduler = new Scheduler(n)const addTask = (time, order) =&gt; &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))&#125;addTask(1000, &#x27;1&#x27;)addTask(500, &#x27;2&#x27;)addTask(300, &#x27;3&#x27;)addTask(400, &#x27;4&#x27;)// 打印顺序是：2 3 1 4 编码 执行add方法时，判断当前并发数。 并发数大于limit，通过await进行阻塞。 并发数小于limit，执行当前任务，并判断是否存在阻塞任务。 123456789101112131415161718192021222324252627282930313233343536373839404142class Scheduler &#123; constructor(n) &#123; this.max = n this.count = 0 this.promises = [] &#125; async add(promiseCreator) &#123; if (this.count &gt;= this.max) &#123; // 当前达到上限 // 该promise应该阻塞 // 将阻塞该promise的resolve方法存储在列表中，用于解除阻塞状态 await new Promise((resolve) =&gt; &#123; this.promises.push(resolve) &#125;) &#125; // 执行当前promise // 记录result this.count++ const result = await promiseCreator() this.count-- // 当前promise执行完毕 // 判断列表中是否存在阻塞的任务 // 存在阻塞任务，则拿出前面的任务，调用resolve解除阻塞状态 if (this.promises.length) &#123; this.promises.shift()() &#125; &#125;&#125;const timeout = (time) =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, time)&#125;)const scheduler = new Scheduler(2)const addTask = (time, order) =&gt; &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order));&#125;addTask(1000, &#x27;1&#x27;)addTask(500, &#x27;2&#x27;)addTask(300, &#x27;3&#x27;)addTask(400, &#x27;4&#x27;)","categories":[{"name":"手写题","slug":"手写题","permalink":"https://leaningzzz.github.io/blog/categories/%E6%89%8B%E5%86%99%E9%A2%98/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"}]},{"title":"promise相关api及其实现","slug":"interview/promise相关api及其实现","date":"2023-02-16T06:07:12.000Z","updated":"2023-02-16T06:09:19.979Z","comments":true,"path":"2023/02/16/interview/promise相关api及其实现/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/16/interview/promise%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"promise.all 接收⼀个Promise数组，数组中如有⾮Promise项，则此项当做成功 如果所有Promise都成功，则返回成功结果数组 如果有⼀个Promise失败，则返回这个失败结果 1234567891011121314151617181920static all(promises) &#123; const result = [] let count = 0 return new MyPromise((resolve, reject) =&gt; &#123; const addData = (index, value) =&gt; &#123; result[index] = value count++ if (count === promises.length) resolve(result) &#125; promises.forEach((promise, index) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(index, res) &#125;, err =&gt; reject(err)) &#125; else &#123; addData(index, promise) &#125; &#125;) &#125;)&#125; promise.race 接收promise数组，如果有非promise的值，返回成功 返回最快得到结果的promise 12345678910111213race(promises) &#123; return new myPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; reject(err)) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; promise.allSettled 接受promise数组，如果有非promise值，返回成功 保存所有promise结果(成功+失败)，返回数组 123456789101112131415161718192021222324252627allSettled(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const res = [] let count = 0 const addData = (status, value, i) =&gt; &#123; res[i] = &#123; status, value &#125; count++ if (count === promises.length) &#123; resolve(res) &#125; &#125; promises.forEach((promise, i) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(&#x27;fulfilled&#x27;, res, i) &#125;, err =&gt; &#123; addData(&#x27;rejected&#x27;, err, i) &#125;) &#125; else &#123; addData(&#x27;fulfilled&#x27;, promise, i) &#125; &#125;) &#125;)&#125; promise.any 接收promise数组，若有非promise直接返回成功 有一个promise成功，返回成功 全部失败报错 1234567891011121314151617181920static any(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach((promise) =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; count++ if (count === promises.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27; )) &#125; &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125;","categories":[{"name":"手写题","slug":"手写题","permalink":"https://leaningzzz.github.io/blog/categories/%E6%89%8B%E5%86%99%E9%A2%98/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"}]},{"title":"2341.数组能形成多少数对","slug":"leetcode/2341-数组能形成多少数对","date":"2023-02-16T03:10:32.000Z","updated":"2023-02-16T03:13:53.050Z","comments":true,"path":"2023/02/16/leetcode/2341-数组能形成多少数对/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/16/leetcode/2341-%E6%95%B0%E7%BB%84%E8%83%BD%E5%BD%A2%E6%88%90%E5%A4%9A%E5%B0%91%E6%95%B0%E5%AF%B9/","excerpt":"","text":"题目链接https://leetcode.cn/problems/maximum-number-of-pairs-in-array/ 思路 排序数组 从0开始遍历，对比[i]和[i+1]是否相等 如果相等，pairs ++ ,i +&#x3D; 2 如果不相等，i++ 返回 [pairs, nums.length-2*pairs] 代码1234567891011121314151617181920212223242526272829303132/* * @lc app=leetcode.cn id=2341 lang=javascript * * [2341] 数组能形成多少数对 */// @lc code=start/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var numberOfPairs = function (nums) &#123; const sorted = nums.sort((a, b) =&gt; a - b) let i = 0, pairs = 0 while (i &lt; sorted.length) &#123; if (sorted[i] === sorted[i + 1]) &#123; pairs++ i += 2 &#125; else &#123; i++ &#125; &#125; console.log(pairs) return [pairs, sorted.length - pairs * 2]&#125;;const nums = [1, 3, 2, 1, 3, 2, 2]// const nums = [1, 1]console.log(numberOfPairs(nums))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"手写call、bind、apply","slug":"interview/手写call、bind、apply","date":"2023-02-14T08:46:50.000Z","updated":"2023-02-16T03:17:38.074Z","comments":true,"path":"2023/02/14/interview/手写call、bind、apply/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/14/interview/%E6%89%8B%E5%86%99call%E3%80%81bind%E3%80%81apply/","excerpt":"","text":"call、bind、apply的用法 改变this指向。 call、apply 改变this后，会执行该方法。 bind返回改变this后的函数 参数不同 123call(this,...args)apply(this,[args])bind(this) 实现 call 将方法挂载到context上进行调用。调用完成后记录result，并删除context上的挂载 12345678910function myCall(context,...args)&#123; if(context === undefined || context === null)&#123; context = window &#125; let symbol = Symbol() context[symbol] = this let result = context[symbol](...args) delete context[symbol] return result&#125; apply与call思路一致 12345678910function myApply (context,args)&#123; if(context === undefined || context === null)&#123; context = window &#125; let symbol = Symbol() context[symbol] = this const result = context[symbol](...args) delete context[symbol] return result&#125; bind返回的是一个方法 123function myBind (context,...args)&#123; &#125;","categories":[{"name":"手写题","slug":"手写题","permalink":"https://leaningzzz.github.io/blog/categories/%E6%89%8B%E5%86%99%E9%A2%98/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"call","slug":"call","permalink":"https://leaningzzz.github.io/blog/tags/call/"},{"name":"bind","slug":"bind","permalink":"https://leaningzzz.github.io/blog/tags/bind/"},{"name":"apply","slug":"apply","permalink":"https://leaningzzz.github.io/blog/tags/apply/"}]},{"title":"1124.表现良好的最长时间段","slug":"leetcode/1124-表现良好的最长时间段","date":"2023-02-14T07:51:38.000Z","updated":"2023-02-14T08:01:50.535Z","comments":true,"path":"2023/02/14/leetcode/1124-表现良好的最长时间段/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/14/leetcode/1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/","excerpt":"","text":"题目链接https://leetcode.cn/problems/longest-well-performing-interval/ 思路 [9,9,6,0,6,6,9] 转为 [1,1,-1,-1,-1,-1,1] 求出转化后的数组中最长的合为正的子数组长度 最后还是用暴力循环求出的解 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * @lc app=leetcode.cn id=1124 lang=javascript * * [1124] 表现良好的最长时间段 */// @lc code=start/** * @param &#123;number[]&#125; hours * @return &#123;number&#125; */var longestWPI = function (hours) &#123; if (hours.every(item =&gt; item &lt;= 8)) &#123; return 0 &#125; const tempArr = hours.map(item =&gt; &#123; if (item &lt;= 8) &#123; return -1 &#125; else &#123; return 1 &#125; &#125;) let result = 0 for (let i = 0; i &lt; tempArr.length; i++) &#123; let temp = 0, maxLength = 0 for (let j = i; j &lt; tempArr.length; j++) &#123; temp = temp + tempArr[j] if (temp &gt; 0 || (temp &gt; 0 &amp;&amp; j === tempArr.length - 1)) &#123; maxLength = Math.max(j - i, maxLength) &#125; &#125; result = Math.max(maxLength + 1, result) &#125; return result&#125;;// const hours = [9, 9, 6, 0, 6, 6, 9]// const hours = [6, 6, 6]// const hours = [6, 6, 9]// const hours = [6, 9, 9]const hours = [6, 6, 8]console.log(longestWPI(hours))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"1234.替换子串得到平衡字符串","slug":"leetcode/1234-替换子串得到平衡字符串","date":"2023-02-13T13:08:27.000Z","updated":"2023-02-14T07:50:43.086Z","comments":true,"path":"2023/02/13/leetcode/1234-替换子串得到平衡字符串/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/13/leetcode/1234-%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目链接https://leetcode.cn/problems/replace-the-substring-for-balanced-string 思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @lc app=leetcode.cn id=1234 lang=javascript * * [1234] 替换子串得到平衡字符串 */// @lc code=start/** * @param &#123;string&#125; s * @return &#123;number&#125; */var balancedString = function (s) &#123; const avg = s.length / 4; let count = &#123; Q: 0, W: 0, E: 0, R: 0 &#125; const checkNum = () =&gt; &#123; // 是否超出平均 for (let key in count) &#123; if (count[key] &gt; avg) &#123; return true &#125; &#125; return false &#125; for (const char of s) &#123; count[char] += 1 &#125; let min = s.length, left = 0; right = 0 while (right &lt;= s.length &amp;&amp; left &lt;= right) &#123; console.log(&#x27;while&#x27;) if (checkNum()) &#123; count[s[right]] -= 1 right++ &#125; else &#123; count[s[left]] += 1 min = Math.min(min, right - left) left++ &#125; &#125; return min&#125;;const s = &quot;QWERQEEE&quot;console.log(balancedString(s))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leaningzzz.github.io/blog/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"1138.字母板上的路径","slug":"leetcode/1138-字母板上的路径","date":"2023-02-12T11:56:01.000Z","updated":"2023-02-14T07:50:28.602Z","comments":true,"path":"2023/02/12/leetcode/1138-字母板上的路径/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1138-%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目链接https://leetcode.cn/problems/alphabet-board-path 思路 从第一个字符开始，找到当前字符在board中的xIndex和yIndex 根据currentIndex和当前字符的xIndex和yIndex，计算该往左右或上下移动 统计结果 循环第二个字符 需要注意z字符的移动，不能超出边界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @lc app=leetcode.cn id=1138 lang=javascript * * [1138] 字母板上的路径 */// @lc code=start/** * @param &#123;string&#125; target * @return &#123;string&#125; */var alphabetBoardPath = function (target) &#123; const board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;] let result = &#x27;&#x27;, curX = 0, curY = 0 for (let i = 0; i &lt; target.length; i++) &#123; const cur = target[i] let xIndex, yIndex board.forEach((item, index) =&gt; &#123; if (item.includes(cur)) &#123; yIndex = index xIndex = item.indexOf(cur) &#125; &#125;) const x = xIndex - curX, y = yIndex - curY const xArr = new Array(Math.abs(x)).fill(x &gt; 0 ? &#x27;R&#x27; : &#x27;L&#x27;), yArr = new Array(Math.abs(y)).fill(y &gt; 0 ? &#x27;D&#x27; : &#x27;U&#x27;) // 需要从其他格子前往z格时，先移动x轴，再移动y轴 // 先移动y轴的话，有可能撞到边界 if (cur === &#x27;z&#x27;) &#123; result += xArr.join(&#x27;&#x27;) + yArr.join(&#x27;&#x27;) + &#x27;!&#x27; &#125; else &#123; result += yArr.join(&#x27;&#x27;) + xArr.join(&#x27;&#x27;) + &#x27;!&#x27; &#125; [curX, curY] = [xIndex, yIndex] &#125; return result&#125;;const target = &quot;zb&quot;// &quot;DDDDD!UUUUURRR!DDDDLLLD!&quot;console.log(alphabetBoardPath(target))// &quot;zb&quot;// 输出：// &quot;DDDDD!RUUUUU!&quot;// 预期结果：// &quot;DDDDD!UUUUUR!&quot;// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"html","slug":"basic/html","date":"2023-02-11T17:54:53.902Z","updated":"2023-02-16T03:17:09.120Z","comments":true,"path":"2023/02/12/basic/html/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/basic/html/","excerpt":"","text":"htmlHTML DOCTYPE的含义？什么是HTML的标准模式与混杂模式？doctype: 文档类型声明，说明这个页面使用什么来编写的。 1&lt;!doctype html&gt; HTML5有哪些语义化标签及其特性？HTML元素有哪些分类与特性？123456&lt;body /&gt;&lt;article /&gt;&lt;nav /&gt;&lt;aside /&gt;&lt;header /&gt;&lt;footer /&gt; 根据结构化的内容，选择合适的标签。 有利于seo。 代码更好的可读性。 标签上加alt 、title，方便其他设备进行解析。 如何检测浏览器是否支持HTML5特性？ 检查特定属性和方法 123!!navigator.geolocation // 地理位置!!window.localStorage!!window.Worker 创建一个元素，看看特定元素有没有对应的属性和方法。 12!!document.createElement(&#x27;canvas&#x27;).getContext!!document.createElement(&#x27;video&#x27;).canPlayType 第三方库 http://modernizr.cn/ HTML中meta的作用？HTML的标签有哪些可以优化SEO？ 保证页面时ssr的 meta中的name相关属性。 123&lt;meta name=&quot;author&quot; content=&quot;aaa@gmail.com&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;xxx xxx system&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;xxx xxx&quot; /&gt; 语义化标签，以一些结构化标签为主。 title meta article header aside footer DOM和BOM有什么区别？javaScript在浏览器环境下一般️由三部分构成。 ECMAScript 核心，描述了js的语法和基本对象。 DOM 文档对象模型，document。提供了一些api，可以操作文档。例如：操作页面元素。 BOM 浏览器对象模型，borwser。提供了一些api，可以操作浏览器。例如：操作路由。 如何实现移动端适配？ 使用媒体查询，根据不同屏幕尺寸设置不同样式。 使用百分比、vw&#x2F;vh，避免使用px。 rem方案。 1px问题先放大 200%，然后 scale(0.5)。 rem方案rem 指 html 的 font-size 大小。 如何禁用页面中的右键、打印、另存为、复制等功能？1234567891011121314151617181920212223// 1. 禁用右键document.oncontextmenu = function () &#123; return false;&#125;document.onmousedown = function(event)&#123; if(event.button === 2)&#123; return false &#125;&#125;// 2. 禁止复制&lt;body oncopy=&quot;nocopy()&quot; /&gt;function nocopy(evenr)&#123; event.returnValue = false&#125;// 3. 禁用f12document.onkeydown = function(event)&#123; if(window.event &amp;&amp; window.event.keyCode === 123)&#123; window.event.returnValue = false &#125;&#125; href&#x3D;”javascript:void(0)”和href&#x3D;”#”区别是什么？href&#x3D;”#”: 锚点默认是#top，会让网页往上走javascript: void(0): 死链接。 对target&#x3D;”_blank”的理解？有什么安全性问题？如何防范？ 当你使用target&#x3D;”_blank”打开一个新的标签页时，新页面的window对象上有一个属性 opener ,它指向的是前一个页面的window对象，因此，后一个新打开的页面就可以控制前一个页面了. 类似与window.open，子页面会拿到当前的句柄。window.opener 123if(window.opener)&#123; window.opener.location.href = &#x27;bad.html&#x27;&#125; 1&lt;a href=&quot;x.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferer&quot;&gt;跳转&lt;/a&gt; 简述页面的存储区别？什么是本地存储？怎么做离线缓存？ cookie 每个cookie不能超过4kb 每个域 20个 比较耗费性能 [ key, value, domain, expireTime, httpOnly, sec, ss ] web storage localStorage： 永久存储 sessionStorage： 会话存储 5MB indexdDB 相当于浏览器端的数据库 application cache pwa service worker 离线缓存 什么是canvas？什么时候需要使用canvas？画布常见动画方案： css svg canvas 什么是PWA？渐进式网页应用核心技术： app mainfest service worker web push 什么是Shadow DOM？web component：真正做到组件化。 原生规范，无需框架，无需编译。 真正意义上的css scope。 123456customElements.define(&#x27;shadow-text&#x27;, class extends HTMLElement &#123; connectedCallback()&#123; const shadow = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;) shadow.innerHtml = &#x27;this is a shadow dom&#x27; &#125;&#125;) iframe有哪些应用？如处理iframe通信？什么是web worker？为什么要使用web worker? web worker赋予了js应用在主线程之外重开一个单独线程的能力，该线程与主线程相分离，互不影响。可通过postMessage、onMessage两个api来进行通信。 避免耗时操作阻塞主线程（将耗时操作移到worker线程中进行，操作结束后通知主线程） 什么是SSO打通？怎么做前端沙盒模式？浏览器的渲染和布局逻辑是什么？ DOM 树构建 CSS 树构建 DOM树 + CSS树 &#x3D; 渲染树构建 页面布局 页面绘制 页面的重绘回流是什么？怎样计算首屏和白屏的时间？常统计的页面性能数据指标包括？页面上有哪些领域可以做进一步的性能优化？浏览器之间的线程调度是怎么做的？","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"html","slug":"html","permalink":"https://leaningzzz.github.io/blog/tags/html/"}]},{"title":"异步","slug":"basic/promise","date":"2023-02-11T17:53:41.010Z","updated":"2023-02-14T08:05:56.159Z","comments":true,"path":"2023/02/12/basic/promise/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/basic/promise/","excerpt":"","text":"异步promisepromise实现 执行resolve -&gt; fulfilled 执行reject -&gt; rejected promise状态改变后不可改变 如果有报错，相当于执行reject 初始状态为pending 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class myPromise &#123; constructor(executor) &#123; // 初始化，定义初始状态 this.initValue() // 初始化this指向 this.initBind() // 执行传入的函数 // catch 执行reject try &#123; executor(this.resolve, this.reject) &#125; catch (e) &#123; this.reject(e) &#125; &#125; initValue() &#123; this.promiseResult = null this.promiseState = &#x27;pending&#x27; this.onFulfilledCbs = [] // 成功回调 this.onRejectedCbs = [] // 失败回调 &#125; initBind() &#123; // this绑定到实例上，方便链式调用？ this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; resolve(value) &#123; if (this.promiseState !== &#x27;pending&#x27;) &#123; return &#125; this.promiseResult = value this.promiseState = &#x27;fulfilled&#x27; // 执行保存的成功过回调 while (this.onFulfilledCbs.length) &#123; this.onFulfilledCbs.shift()(this.promiseResult) &#125; &#125; reject(reason) &#123; if (this.promiseState !== &#x27;pending&#x27;) &#123; return &#125; this.promiseResult = reason this.promiseState = &#x27;rejected&#x27; while (this.onRejectedCbs.length) &#123; this.onRejectedCbs.shift()(this.promiseResult) &#125; &#125; then(onFulfilled, onRejected) &#123; // 参数类型判断 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; // 保证链式调用，返回一个新的promise对象 const thenPromise = new myPromise((resolve, reject) =&gt; &#123; const resolvePromise = (cb) =&gt; &#123; try &#123; console.log(&#x27;=======&gt;cb&#x27;, cb) const x = cb(this.promiseResult) if (x &amp;&amp; x === thenPromise) &#123; throw new Error(&#x27;不能返回自身&#x27;) &#125; if (x instanceof myPromise) &#123; x.then(resolve, reject) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; reject(e) throw new Error(e) &#125; &#125; // 状态不为pending -&gt; 执行对应状态的回调 // 状态为pending -&gt; 保存回调，异步结束后执行 if (this.promiseState === &#x27;fulfilled&#x27;) &#123; resolvePromise(onFulfilled) &#125; else if (this.promiseState === &#x27;rejected&#x27;) &#123; resolvePromise(onRejected) // onRejected(this.promiseResult) &#125; else if (this.promiseState === &#x27;pending&#x27;) &#123; this.onFulfilledCbs.push(resolvePromise.bind(this, onFulfilled)) this.onRejectedCbs.push(resolvePromise.bind(this, onRejected)) &#125; &#125;) return thenPromise &#125;&#125;console.log(&#x27;========&gt;1&#x27;)const test = new myPromise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(&#x27;aaa&#x27;) &#125;, 300)&#125;)console.log(&#x27;========&gt;2&#x27;)test.then(res =&gt; console.log(&#x27;====&gt;res&#x27;, res))console.log(&#x27;========&gt;3&#x27;, test.then(res =&gt; console.log(&#x27;====&gt;res&#x27;, res))) promise.all 接收⼀个Promise数组，数组中如有⾮Promise项，则此项当做成功 如果所有Promise都成功，则返回成功结果数组 如果有⼀个Promise失败，则返回这个失败结果 1234567891011121314151617181920static all(promises) &#123; const result = [] let count = 0 return new MyPromise((resolve, reject) =&gt; &#123; const addData = (index, value) =&gt; &#123; result[index] = value count++ if (count === promises.length) resolve(result) &#125; promises.forEach((promise, index) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(index, res) &#125;, err =&gt; reject(err)) &#125; else &#123; addData(index, promise) &#125; &#125;) &#125;)&#125; promise.race 接收promise数组，如果有非promise的值，返回成功 返回最快得到结果的promise 12345678910111213race(promises) &#123; return new myPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; reject(err)) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; promise.allSettled 接受promise数组，如果有非promise值，返回成功 保存所有promise结果(成功+失败)，返回数组 123456789101112131415161718192021222324252627allSettled(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const res = [] let count = 0 const addData = (status, value, i) =&gt; &#123; res[i] = &#123; status, value &#125; count++ if (count === promises.length) &#123; resolve(res) &#125; &#125; promises.forEach((promise, i) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(&#x27;fulfilled&#x27;, res, i) &#125;, err =&gt; &#123; addData(&#x27;rejected&#x27;, err, i) &#125;) &#125; else &#123; addData(&#x27;fulfilled&#x27;, promise, i) &#125; &#125;) &#125;)&#125; promise.any 接收promise数组，若有非promise直接返回成功 有一个promise成功，返回成功 全部失败报错 1234567891011121314151617181920static any(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach((promise) =&gt; &#123; if (promise instanceof myPromise) &#123; promise.then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; count++ if (count === promises.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27; )) &#125; &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; async await12345678910111213function request(num)&#123; return new Promise((res,rej)=&gt;&#123; setTimeout(()=&gt;&#123; res(num * 2) &#125;,1000) &#125;)&#125;request(1).then(res1=&gt;&#123; console.log(res1)&#125;)request(2).then(res1=&gt;&#123; console.log(res1)&#125;) 如果 await 后面跟的不是promise，是没法实现类似异步转同步的效果的，例如await 一个 setTimeout generator","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"},{"name":"异步","slug":"异步","permalink":"https://leaningzzz.github.io/blog/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"css","slug":"basic/css","date":"2023-02-11T17:18:22.432Z","updated":"2023-02-16T03:17:05.279Z","comments":true,"path":"2023/02/12/basic/css/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/basic/css/","excerpt":"","text":"CSS块级元素和行内元素转换的方式有哪些？ display 1display: block / inline-block float 1float: left/right =&gt; display: block =&gt; 去除行内元素之间的空白问题 position 1position: absolute /fixed 选择器 &amp; 优先级选择器的优先级是什么样的？1234567891011121314内联样式 权重最高 1000id选择器 #id 100类选择器 .class 10属性选择器 a[ref=&#x27;link&#x27;] 10标签选择器 div 1伪类选择器 li:last-child 10伪元素选择器 li:before 1兄弟选择器 div+p 0子选择器 ul&gt;li 0后代选择器 li a 0通配符 * 0 特殊场景优先级如何判断？ !important 优先级最高 如果优先级相同，后者高于前者 继承得到的样式，优先级是最低的 可继承的样式有哪些？ 字体 font-family font-weight font-size font-style 文本 text-indent 缩进 text-align line-height word-spacing letter-spacing color 元素 visibility 列表布局 list-style 光标 cursor 隐藏和显示相关有哪些隐藏元素的方法？有什么区别？ display:none; 不占位 visibility: hidden; 占位 opacity: 0; 占位 z-index: 负值; 不占位（被覆盖了） transform: scale(0, 0); 占位（位置变小了） display 和 visibility 有什么区别？ 都可以让元素进行隐藏&#x2F;展示。 浏览器渲染时，display不占据空间，渲染书中会不存在；visibility 占据一根树枝，只是不进行展示。 visibility 是可继承，而display不会被继承。 性能影响上，display会导致文档重排，但是修改visibility只会导致文本重绘。 盒模型及其特性简单说说标准盒模型、IE盒模型分别是什么？如何转换？盒模型特点：content + padding + border + margin 区别：标准盒模型： width 和 height 只包含 content 部分。IE盒模型： width 和 height 包含了 content + padding + border 转换方式：box-sizing: content-box &#x2F; border-box 伪元素和伪类是什么？区别是什么？伪元素： 只出现在css样式表中，不存在与文档流中。 1234567p::before&#123; content: &#x27;aa&#x27;;&#125;p::first-line&#123; background: red;&#125; 伪类：在已有的元素上加上特殊的类别，不产生新的类别。 123456div:hover&#123; color: red;&#125;li:last-child&#123; color: red;&#125; 图片格式和css-sprites图片格式有哪些？怎么应用？如何选择？ BMP：无损、无压缩。通常体积较大。 GIF：无损，采用了LZW压缩算法。仅支持8bit索引色，色彩还原度较差，但支持动图。 JPEG：有损、直接色存储，适合还原度要求较高的场景。 PNG-8：无损、使用索引色。体积更优秀，并且支持透明度调节。 PNG-24：无损，使用直接色存储。 SVG：无损，放大不会失真，适合做logo、icon webP：有损+无损、使用直接色、支持透明度、压缩。兼容性不太好。 css-sprites 精灵图、雪碧图怎么处理？把所有涉及到的图片放到一张大图中，利用background-image将一张大图加载到页面中，通过background-repeat + background-position将对应图片移动到窗口中显示。 优点： 性能缺点： 开发、维护 像素密度和图片应用像素密度有了解吗？经典设备宽高 414px 896px物理像素 1242px 2688px 1242 &#x2F; 414 &#x3D; 3 &#x3D;&gt; 逻辑像素 ： 物理像素 &#x3D; 1 ：3&#x3D;&gt; 像素密度、DPI 3&#x3D;&gt; 3倍屏 如何在图片的加载上应用动态密度？设计师提供 2x 3x 图片 12345678image&#123; background: (&#x27;1x.png&#x27;)&#125;@media only screen and (min-device-pixel-ratio: 3)&#123; image&#123; background: (&#x27;3x.png&#x27;) &#125;&#125; css工程化与预处理css类库与工程化的理解？预处理器：less csss stylus&#x3D;&gt; 利用编译库提供能力，提供层级、mixin、变量、循环、函数 后处理器：postCss&#x3D;&gt; 利用后处理编译，给写好的css增加一些属性或进行变量替换，实现跨浏览器兼容 单行、多行文本超出手写一个单行 &amp; 多行文本超出省略12345678910111213141516171819202122232425262728293031&lt;!--单行超出--&gt;style&#123; overflow:hidden; text-overflow: ellipsis; // 超出省略号 wite-space: nowrap; // 不换行&#125;&lt;!--多行超出--&gt;style&#123; overflow:hidden; text-overflow: ellipsis; // 超出省略号 display: -webkit-box; // 弹性伸缩盒子模型 -webkit-box-orient: vertical; // 从上往下垂直排列 -webkit-line-clamp: 3; // 显示行数&#125;&lt;!--兼容性方案--&gt;p&#123; position: relative; line-height: 18px; height: 40px; // 必须知道行高 overflow: hidden;&#125;p::after&#123; content: &#x27;...&#x27;; position: absolute; bottom: 0; right: 0;&#125;&lt;!--方案不足：必须固定行高 =&gt; js处理 后处理器处理--&gt; px em rem多种单位的区别","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leaningzzz.github.io/blog/tags/css/"},{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}]},{"title":"http","slug":"basic/http","date":"2023-02-11T17:18:22.423Z","updated":"2023-02-22T06:54:34.814Z","comments":true,"path":"2023/02/12/basic/http/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/basic/http/","excerpt":"","text":"什么是http？什么是https？http：基于 tcp&#x2F;id。是一个客户端和服务端请求和响应的标准，用于从 www 服务器传输超文本到本地浏览器的超文本传输协议。 https：是以安全为目标的 HTTP 通道，通过在 HTTP 下加入 SSL 层进行加密。其作用是 建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 http 和 https 的区别和优缺点？ http 是超文本传输协议，信息是明文传输。HTTPS 协议要比 HTTP 协议更加安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。 http 协议的默认端口为80，https 的默认端口为 443。 https 协议需要 ca 证书，费用较高。 SSL 证书需要绑定 IP。 https 协议的工作原理？ 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 连接。 web 服务器收到客户端的请求之后，会将网站的证书（包含公钥）传输给客户端。 客户端和 web 服务器端开始协商 ssl 链接的安全等级（加密等级）。 客户端、浏览器通过双方协商一致的安全登记，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 客户端通过会话密钥加密与客户端之间的通信。 https 一定是安全的吗？不一定。中间人攻击。中间人与用户或服务器在同一个局域网，中间人可以截获用户的数据包，包括SSL数据包，并做一个假的服务器SSL证书与用户通信，从而截获用户输入的机密信息。当网站被假的SSL证书替换时，浏览器会警告用户此证书不受信任，需要用户确认是否信任此证书，用户习惯性点击“继续浏览”，中间人攻击轻而易举的实现了。 什么是三次握手？三次握手是客户端与服务器在建立TCP连接时的步骤。在握手的过程中传送的包里不含数据，三次握手完毕后，客户端和服务器才正式开始传送数据。 第一次握手： 建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入 SYN_SENT 状态，等待服务器确认。 第二次握手：服务器收到syn包，并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack&#x3D;k+1），此包发送完毕，客户端与服务器进入*ESTABLTSHED（TCP连接成功）*状态，完成三次握手。 TCP和UDP的区别？ TCP 是面向连接的，UDP无连接。 TCP 仅支持单播传输，UDP 提供了单播、多播、广播的功能。 TCP 可靠，三次握手保证了连接的可靠性。UDP 不可靠，UDP 是无连接的，通信不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。 UDP 开销小（不需要连接），数据传输效率更高，实时性更好。 什么是请求跨域？跨域指由于浏览器的同源同域策略，不能执行其他网站的脚本。（为了安全）同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。 怎么解决请求跨域的问题？ JSONPscript标签、image标签中的src属性不受浏览器同源同域策略影响，因此可以利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。 12345678910111213//动态创建 scriptvar script = document.createElement(&#x27;script&#x27;)// 设置回调函数function getData(data) &#123; console.log(data)&#125;//设置 script 的 src 属性，并设置请求地址script.src = &#x27;http://localhost:3000/?callback=getData&#x27;// 让 script 生效document.body.appendChild(script) 缺点：只支持get CORSCORS(Cross-origin resource sharing)跨域资源共享。服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求 proxy代理目前常用方式,通过服务器设置代理。客户端向服务端请求会产生跨域，但服务端向服务端请求不存在跨域。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"http","slug":"http","permalink":"https://leaningzzz.github.io/blog/tags/http/"},{"name":"网络","slug":"网络","permalink":"https://leaningzzz.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"2331.计算布尔二叉树的值","slug":"leetcode/2331-计算布尔二叉树的值","date":"2023-02-11T17:10:58.000Z","updated":"2023-02-14T07:51:15.128Z","comments":true,"path":"2023/02/12/leetcode/2331-计算布尔二叉树的值/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/2331-%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%80%BC/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * * [2331] 计算布尔二叉树的值 * * 思路： * 递归 * root.val为0或1时，返回对应的false或true * root.val为2或3时，递归计算值，并取 || 或 &amp;&amp; *//* * @lc app=leetcode.cn id=2331 lang=javascript * * [2331] 计算布尔二叉树的值 */// @lc code=start/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var evaluateTree = function (root) &#123; // 0: false // 1: true // 2: or // 3: and // root = [2,1,3,null,null,0,1] function loop(root) &#123; if (root.val === 0) return false if (root.val === 1) return true if (root.val === 2) return loop(root.left) || loop(root.right) if (root.val === 3) return loop(root.left) &amp;&amp; loop(root.right) &#125; return loop(root)&#125;;// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"1797.设计一个验证系统","slug":"leetcode/1797-设计一个验证系统","date":"2023-02-11T17:10:37.000Z","updated":"2023-02-14T07:51:11.919Z","comments":true,"path":"2023/02/12/leetcode/1797-设计一个验证系统/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1797-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @param &#123;number&#125; timeToLive */var AuthenticationManager = function (timeToLive) &#123; this.timeToLive = timeToLive this.tokenMap = new Map()&#125;;/** * @param &#123;string&#125; tokenId * @param &#123;number&#125; currentTime * @return &#123;void&#125; */AuthenticationManager.prototype.generate = function (tokenId, currentTime) &#123; if (!this.tokenMap.has(tokenId)) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null&#125;;/** * @param &#123;string&#125; tokenId * @param &#123;number&#125; currentTime * @return &#123;void&#125; */AuthenticationManager.prototype.renew = function (tokenId, currentTime) &#123; if (this.tokenMap.has(tokenId) &amp;&amp; this.tokenMap.get(tokenId) + this.timeToLive &gt; currentTime) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null&#125;;/** * @param &#123;number&#125; currentTime * @return &#123;number&#125; */AuthenticationManager.prototype.countUnexpiredTokens = function (currentTime) &#123; let nums = 0 this.tokenMap.forEach((value, key) =&gt; &#123; if (value + this.timeToLive &gt; currentTime) &#123; nums++ &#125; &#125;) return nums&#125;;/** * Your AuthenticationManager object will be instantiated and called as such: * var obj = new AuthenticationManager(timeToLive) * obj.generate(tokenId,currentTime) * obj.renew(tokenId,currentTime) * var param_3 = obj.countUnexpiredTokens(currentTime) */class AuthenticationManager &#123; constructor(timeToLive) &#123; this.timeToLive = timeToLive this.tokenMap = new Map() &#125; generate(tokenId, currentTime) &#123; if (!this.tokenMap.has(tokenId)) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null &#125; renew(tokenId, currentTime) &#123; if (this.tokenMap.has(tokenId) &amp;&amp; this.tokenMap.get(tokenId) + this.timeToLive &gt; currentTime) &#123; this.tokenMap.set(tokenId, currentTime) &#125; return null &#125; countUnexpiredTokens(currentTime) &#123; let nums = 0 this.tokenMap.forEach((value, key) =&gt; &#123; if (value + this.timeToLive &gt; currentTime) &#123; nums++ &#125; &#125;) return nums &#125;&#125;// const authenticationManager = new AuthenticationManager(5)// authenticationManager.renew(&quot;aaa&quot;, 1)// authenticationManager.generate(&quot;aaa&quot;, 2)// authenticationManager.countUnexpiredTokens(6)// authenticationManager.generate(&quot;bbb&quot;, 7)// authenticationManager.renew(&quot;aaa&quot;, 8)// authenticationManager.renew(&quot;bbb&quot;, 10)// authenticationManager.countUnexpiredTokens(15)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"1604.警告一小时内使用相同员工卡大于等于三次的人","slug":"leetcode/1604-警告一小时内使用相同员工卡大于等于三次的人","date":"2023-02-11T17:10:14.000Z","updated":"2023-02-14T07:51:09.656Z","comments":true,"path":"2023/02/12/leetcode/1604-警告一小时内使用相同员工卡大于等于三次的人/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1604-%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * * [1604] 警告一小时内使用相同员工卡大于等于三次的人 * * 思路： * 1. 输入数据格式化，转换成key value形式 * 2. 对每个成员的打卡数据进行分析 * 2.1 打卡数据转为分钟数 * 2.2 排序 * 2.3 从第二个数据开始(i=2)，如果 times[i] - times[i=2] &gt;=60，符合条件，否则i++ * 2.4 如果存在符合条件的打卡数据，则为true，否则为false * 3. 将所有true的成员进行排序 * 4. 输出 *//* * @lc app=leetcode.cn id=1604 lang=javascript * * [1604] 警告一小时内使用相同员工卡大于等于三次的人 */// @lc code=start/** * @param &#123;string[]&#125; keyName * @param &#123;string[]&#125; keyTime * @return &#123;string[]&#125; *//** * @param &#123;string[]&#125; keyName * @param &#123;string[]&#125; keyTime * @return &#123;string[]&#125; */var alertNames = function (keyName, keyTime) &#123; const obj = &#123;&#125; for (let i = 0; i &lt; keyName.length; i++) &#123; const name = keyName[i] if (!obj[name]) &#123; obj[name] = [] &#125; obj[name].push(keyTime[i]) &#125; const timeToMin = (time) =&gt; &#123; const [hour, min] = time.split(&#x27;:&#x27;) return Number(hour * 60) + Number(min) &#125; const check = (times) =&gt; &#123; times = times.map(item =&gt; timeToMin(item)).sort((a, b) =&gt; a - b) for (let i = 2; i &lt; times.length; i++) &#123; if (times[i] - times[i - 2] &lt;= 60) &#123; return true &#125; &#125; return false &#125; return Object.keys(obj).filter(item =&gt; check(obj[item])).sort()&#125;;console.log(alertNames([&quot;daniel&quot;, &quot;daniel&quot;, &quot;daniel&quot;, &quot;luis&quot;, &quot;luis&quot;, &quot;luis&quot;, &quot;luis&quot;], [&quot;10:00&quot;, &quot;10:40&quot;, &quot;11:00&quot;, &quot;09:00&quot;, &quot;11:00&quot;, &quot;13:00&quot;, &quot;15:00&quot;]))// // @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"1233.删除子文件夹","slug":"leetcode/1233-删除子文件夹","date":"2023-02-11T17:09:50.000Z","updated":"2023-02-14T07:50:47.176Z","comments":true,"path":"2023/02/12/leetcode/1233-删除子文件夹/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @lc app=leetcode.cn id=1233 lang=javascript * * [1233] 删除子文件夹 */// @lc code=start/** * @param &#123;string[]&#125; folder * @return &#123;string[]&#125; */// var removeSubfolders = function (folder) &#123;// folder = folder.sort()// const arr = new Set([])// for (let i = 0; i &lt; folder.length; i++) &#123;// for (let j = i + 1; j &lt; folder.length; j++) &#123;// console.log(folder[i], folder[j], i, j)// if (folder[j].indexOf(folder[i]) === 0 &amp;&amp; folder[i] !== folder[j]) &#123;// console.log(folder[i], folder[j], i, j)// if (folder[j].split(folder[i])[1][0] === &#x27;/&#x27;) &#123;// // 排除/a/b/c /a/b/ca// console.log(folder[i], folder[j], i, j)// arr.add(j)// &#125;// &#125;// &#125;// &#125;// return folder.filter((item, index) =&gt; &#123;// return ![...arr].includes(index)// &#125;)// &#125;;var removeSubfolders = function (folder) &#123; folder = folder.sort() const result = new Set() for (let i = 0; i &lt; folder.length; i++) &#123; let str = &#x27;/&#x27;, isSon = false for (let j = 1; j &lt; folder[i].length; j++) &#123; if (folder[i][j] === &#x27;/&#x27; &amp;&amp; result.has(str)) &#123; isSon = true break &#125; str += folder[i][j] &#125; if (!isSon) &#123; result.add(folder[i]) &#125; &#125; return [...result]&#125;;// @lc code=end// const folder = [&quot;/a&quot;, &quot;/a/b&quot;, &quot;/c/d&quot;, &quot;/c/d/e&quot;, &quot;/c/f&quot;]// const folder = [&quot;/ah/al/am&quot;, &quot;/ah/al&quot;]const folder = [&quot;/a&quot;, &quot;/a/b/c&quot;, &quot;/a/b/d&quot;]// const folder = [&quot;/a&quot;, &quot;/a/b&quot;, &quot;/c/d&quot;, &quot;/c/d/e&quot;, &quot;/c/f&quot;]console.log(removeSubfolders(folder))","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"20.有效括号","slug":"leetcode/20-有效括号","date":"2023-02-11T17:09:18.000Z","updated":"2023-02-22T02:39:06.331Z","comments":true,"path":"2023/02/12/leetcode/20-有效括号/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334/* * @lc app=leetcode.cn id=20 lang=javascript * * [20] 有效的括号 */// @lc code=start/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function (s) &#123; const map = &#123; &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27; &#125; const arr = [] for (let i = 0; i &lt; s.length; i++) &#123; if (map[s[i]]) &#123;//left arr.push(s[i]) &#125; else &#123; if (map[arr[arr.length - 1]] !== s[i]) &#123; return false &#125; arr.pop() &#125; &#125; return arr.length === 0&#125;;s = &quot;(]&quot;console.log(isValid(s))// @lc code=end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"2335.装满杯子需要的最短总时长","slug":"leetcode/2335-装满杯子需要的最短总时长","date":"2023-02-11T16:32:23.000Z","updated":"2023-02-14T07:51:17.831Z","comments":true,"path":"2023/02/12/leetcode/2335-装满杯子需要的最短总时长/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/leetcode/2335-%E8%A3%85%E6%BB%A1%E6%9D%AF%E5%AD%90%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E7%9F%AD%E6%80%BB%E6%97%B6%E9%95%BF/","excerpt":"","text":"12345678910111213141516171819202122232425262728/* * @lc app=leetcode.cn id=2335 lang=javascript * * [2335] 装满杯子需要的最短总时长 */// @lc code=start/** * @param &#123;number[]&#125; amount * @return &#123;number&#125; */var fillCups = function (amount) &#123; let [first, second, third] = amount.sort((a, b) =&gt; a - b) console.log(first, second, third) if (first + second &lt;= third) &#123; return third &#125; else &#123; return Math.ceil((first + second + third) / 2) &#125;&#125;;// const amount = [1, 4, 2]const amount = [7, 10, 1]console.log(fillCups(amount))// @lc code=end// 3 + 2 + 2","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"React","slug":"react/react基础","date":"2023-02-11T16:32:03.000Z","updated":"2023-02-23T07:39:57.516Z","comments":true,"path":"2023/02/12/react/react基础/","link":"","permalink":"https://leaningzzz.github.io/blog/2023/02/12/react/react%E5%9F%BA%E7%A1%80/","excerpt":"","text":"事件中，箭头函数和bind的区别 事件 react合成事件，统一挂载到根元素上 挂载到根元素上的弊端 React.portal 父组件更新，子组件一定更新吗？ 子组件更新，父组件会不会更新？ shouldComponentUpdate在provider&#x2F;context更新时无效，即总会render 性能优化 pureComponent：相当于在shouldComponent里进行浅对比 React.memo shouldComponentUpdate 反模式？ 组件通信— 父 -&gt; 子 props context provider consumer 性能优化组件复用HOC高阶段组件 属性代理：通过HOC为传入组件增加新属性 12345678function Hoc(Component)&#123; const newProps = &#123;aa:1&#125; return class extend React.Component&#123; render()&#123; return &lt;Component &#123;...newProps&#125; /&gt; &#125; &#125;&#125; 反向继承：使用super访问传入生命周期 高阶组件的问题 内部黑盒 &#x3D;&gt; 增加理解成本假设通过HOC生成了一个Comp组件。此时如果想了解Comp组件的逻辑，则需要同时查看HOC组件的逻辑以及传入HOC的入参组件逻辑 属性覆盖 render propshooks useState useEffect useRef useImperativeHandle useCallback useMemo useContext useReducer React18新特性Suspence + React.lazyssr流式渲染renderToPipableStream transition(https://www.qycn.com/xzx/article/14478.html) immutable","categories":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"React","slug":"React","permalink":"https://leaningzzz.github.io/blog/tags/React/"}]}],"categories":[{"name":"手写题","slug":"手写题","permalink":"https://leaningzzz.github.io/blog/categories/%E6%89%8B%E5%86%99%E9%A2%98/"},{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/categories/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"leetcode","slug":"leetcode","permalink":"https://leaningzzz.github.io/blog/categories/leetcode/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://leaningzzz.github.io/blog/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"面试资料","slug":"面试资料","permalink":"https://leaningzzz.github.io/blog/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"浏览器","slug":"浏览器","permalink":"https://leaningzzz.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"https://leaningzzz.github.io/blog/tags/%E7%BC%93%E5%AD%98/"},{"name":"每日一题","slug":"每日一题","permalink":"https://leaningzzz.github.io/blog/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"promise","slug":"promise","permalink":"https://leaningzzz.github.io/blog/tags/promise/"},{"name":"call","slug":"call","permalink":"https://leaningzzz.github.io/blog/tags/call/"},{"name":"bind","slug":"bind","permalink":"https://leaningzzz.github.io/blog/tags/bind/"},{"name":"apply","slug":"apply","permalink":"https://leaningzzz.github.io/blog/tags/apply/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leaningzzz.github.io/blog/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"html","slug":"html","permalink":"https://leaningzzz.github.io/blog/tags/html/"},{"name":"异步","slug":"异步","permalink":"https://leaningzzz.github.io/blog/tags/%E5%BC%82%E6%AD%A5/"},{"name":"css","slug":"css","permalink":"https://leaningzzz.github.io/blog/tags/css/"},{"name":"http","slug":"http","permalink":"https://leaningzzz.github.io/blog/tags/http/"},{"name":"网络","slug":"网络","permalink":"https://leaningzzz.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","permalink":"https://leaningzzz.github.io/blog/tags/React/"}]}